{"version":3,"sources":["lib/HashMap/index.ts"],"names":["sDefinition","Symbol","sValueMap","defaultGetFunction","item","HashMap","definition","Object","assign","Map","key","prototype","hasOwnProperty","call","defineProperty","get","enumerable","set","freeze","map","value","has","getKey","getValue","forEach","createHashMap"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,WAAW,GAAGC,MAAM,CAAC,YAAD,CAA1B;AACA,IAAMC,SAAS,GAAGD,MAAM,CAAC,UAAD,CAAxB;;AAEO,SAASE,kBAAT,CAA4BC,IAA5B,EAAkC;AACvC,SAAOA,IAAP;AACD;AAED;;;;;;IAIqBC,O;;;AACnB;;;;AAIA,mBAAYC,UAAZ,EAAwB;AAAA;;AAAA;;AACtB,SAAKN,WAAL,IAAoBO,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,UAAlB,CAApB;AACA,SAAKJ,SAAL,IAAkB,IAAIO,GAAJ,EAAlB;;AAFsB,+BAIXC,GAJW;AAKpB;AACA,UAAIH,MAAM,CAACI,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCP,UAArC,EAAiDI,GAAjD,CAAJ,EAA2D;AACzDH,QAAAA,MAAM,CAACO,cAAP,CAAsB,KAAtB,EAA4BJ,GAA5B,EAAiC;AAC/BK,UAAAA,GAD+B,iBACzB;AACJ,mBAAO,KAAKf,WAAL,EAAkBU,GAAlB,CAAP;AACD,WAH8B;AAI/BM,UAAAA,UAAU,EAAE;AAJmB,SAAjC;;AAMA,QAAA,KAAI,CAACd,SAAD,CAAJ,CAAgBe,GAAhB,CAAoB,KAAI,CAACjB,WAAD,CAAJ,CAAkBU,GAAlB,CAApB,EAA4CA,GAA5C;AACD;AAdmB;;AAItB,SAAK,IAAMA,GAAX,IAAkBJ,UAAlB,EAA8B;AAAA,YAAnBI,GAAmB;AAW7B;;AACDH,IAAAA,MAAM,CAACW,MAAP,CAAc,IAAd;AACD;;;;2BAEaC,G,EAAKC,K,EAAO;AACxB,aAAOD,GAAG,CAACjB,SAAD,CAAH,CAAea,GAAf,CAAmBK,KAAnB,CAAP;AACD;;;6BAEeD,G,EAAKC,K,EAAO;AAC1B,aAAOD,GAAG,CAACjB,SAAD,CAAH,CAAemB,GAAf,CAAmBD,KAAnB,CAAP;AACD;;;kCAME;AAAA,UAHDH,GAGC,QAHDA,GAGC;AAAA,6BAFDK,MAEC;AAAA,UAFDA,MAEC,4BAFQnB,kBAER;AAAA,+BADDoB,QACC;AAAA,UADDA,QACC,8BADUpB,kBACV;AACD,UAAMG,UAAU,GAAG,EAAnB;;AACA,yBAAIW,GAAJ,EAASO,OAAT,CAAiB,UAACpB,IAAD,EAAU;AACzB,YAAMM,GAAG,GAAGY,MAAM,CAAClB,IAAD,CAAlB;AACA,YAAMgB,KAAK,GAAGG,QAAQ,CAACnB,IAAD,CAAtB;;AACA,YAAI,OAAOM,GAAP,KAAe,WAAf,IAA8BA,GAAG,KAAK,IAAtC,IAA8CA,GAAG,KAAK,EAA1D,EAA8D;AAC5DJ,UAAAA,UAAU,CAACI,GAAD,CAAV,GAAkBU,KAAlB;AACD;AACF,OAND;;AAOA,aAAO,IAAIf,OAAJ,CAAYC,UAAZ,CAAP;AACD;;;;;;;;AAGI,SAASmB,aAAT,CACLnB,UADK,EAE8C;AACnD,SAAO,IAAID,OAAJ,CAAYC,UAAZ,CAAP;AACD","sourcesContent":["const sDefinition = Symbol('definition');\nconst sValueMap = Symbol('valueMap');\n\nexport function defaultGetFunction(item) {\n  return item;\n}\n\n/**\n * @class HashMap\n * @description Simple hash map class\n */\nexport default class HashMap {\n  /**\n   * @constructor\n   * @param {Object} definition\n   */\n  constructor(definition) {\n    this[sDefinition] = Object.assign({}, definition);\n    this[sValueMap] = new Map();\n\n    for (const key in definition) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(definition, key)) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this[sDefinition][key];\n          },\n          enumerable: true,\n        });\n        this[sValueMap].set(this[sDefinition][key], key);\n      }\n    }\n    Object.freeze(this);\n  }\n\n  static getKey(map, value) {\n    return map[sValueMap].get(value);\n  }\n\n  static hasValue(map, value) {\n    return map[sValueMap].has(value);\n  }\n\n  static fromSet({\n    set,\n    getKey = defaultGetFunction,\n    getValue = defaultGetFunction,\n  }) {\n    const definition = {};\n    [...set].forEach((item) => {\n      const key = getKey(item);\n      const value = getValue(item);\n      if (typeof key !== 'undefined' && key !== null && key !== '') {\n        definition[key] = value;\n      }\n    });\n    return new HashMap(definition);\n  }\n}\n\nexport function createHashMap<V extends string, P>(\n  definition: { [K in V]: string },\n): { [K in V]: string } & { [K in keyof P]: string } {\n  return new HashMap(definition) as any;\n}\n"],"file":"index.js"}