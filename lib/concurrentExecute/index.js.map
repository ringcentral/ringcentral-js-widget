{"version":3,"sources":["lib/concurrentExecute/index.js"],"names":["concurrentExecute","promiseThunks","concurrency","delay","options","promise","Promise","delayFn","sleep","Array","isArray","length","Error","all","map","_promise","apply","slice","current","rest"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;SAC8BA,iB;;;;;+EAAf,iBACbC,aADa,EAEbC,WAFa,EAGbC,KAHa;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIbC,YAAAA,OAJa,2DAIH,EAJG;AAAA,+BAMkCA,OANlC,CAMLC,OANK,EAMLA,OANK,iCAMKC,OANL,wCAMkCF,OANlC,CAMcG,OANd,EAMcA,OANd,iCAMwBC,iBANxB;;AAAA,kBAOT,CAACC,KAAK,CAACC,OAAN,CAAcT,aAAd,CAAD,IAAiCA,aAAa,CAACU,MAAd,IAAwB,CAPhD;AAAA;AAAA;AAAA;;AAAA,6CAQJ,EARI;;AAAA;AAAA,kBAUT,OAAOV,aAAa,CAAC,CAAD,CAApB,KAA4B,UAVnB;AAAA;AAAA;AAAA;;AAAA,kBAWL,IAAIW,KAAJ,CAAU,uCAAV,CAXK;;AAAA;AAAA,kBAaTX,aAAa,CAACU,MAAd,IAAwBT,WAbf;AAAA;AAAA;AAAA;;AAAA,6CAcJG,OAAO,CAACQ,GAAR,CAAYZ,aAAa,CAACa,GAAd,CAAkB,UAACC,QAAD;AAAA,qBAAcA,QAAQ,CAACC,KAAT,CAAe,KAAf,CAAd;AAAA,aAAlB,CAAZ,CAdI;;AAAA;AAAA;AAAA,mBAgBShB,iBAAiB,CACrCC,aAAa,CAACgB,KAAd,CAAoB,CAApB,EAAuBf,WAAvB,CADqC,EAErCA,WAFqC,EAGrCC,KAHqC,EAIrCC,OAJqC,CAhB1B;;AAAA;AAgBPc,YAAAA,OAhBO;;AAAA,iBAsBTf,KAtBS;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAuBLI,OAAO,CAACJ,KAAD,CAvBF;;AAAA;AAAA;AAAA,mBAyBMH,iBAAiB,CAClCC,aAAa,CAACgB,KAAd,CAAoBf,WAApB,CADkC,EAElCA,WAFkC,EAGlCC,KAHkC,EAIlCC,OAJkC,CAzBvB;;AAAA;AAyBPe,YAAAA,IAzBO;AAAA,0EA+BFD,OA/BE,sBA+BUC,IA/BV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import sleep from '../sleep';\n\n/**\n * With concurrentExecute helper function, you could control\n * the concurrency and delay of your Promise.all execution.\n * @param {Array<Function>} promiseThunks A set of thunk functions of Promise\n * @param {Number} concurrency Concurrent granularity\n * @param {Number} delay Batch execution delay\n * @param {Function} delayFn Specify your own delay function\n */\nexport default async function concurrentExecute(\n  promiseThunks,\n  concurrency,\n  delay,\n  options = {},\n) {\n  const { promise = Promise, delayFn = sleep } = options;\n  if (!Array.isArray(promiseThunks) || promiseThunks.length <= 0) {\n    return [];\n  }\n  if (typeof promiseThunks[0] !== 'function') {\n    throw new Error('concurrentExecute needs promise thunk');\n  }\n  if (promiseThunks.length <= concurrency) {\n    return promise.all(promiseThunks.map((_promise) => _promise.apply(this)));\n  }\n  const current = await concurrentExecute(\n    promiseThunks.slice(0, concurrency),\n    concurrency,\n    delay,\n    options,\n  );\n  if (delay) {\n    await delayFn(delay);\n  }\n  const rest = await concurrentExecute(\n    promiseThunks.slice(concurrency),\n    concurrency,\n    delay,\n    options,\n  );\n  return [...current, ...rest];\n}\n"],"file":"index.js"}