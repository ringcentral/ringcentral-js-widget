{"version":3,"sources":["lib/ObjectMap/ObjectMap.ts"],"names":["sDefinition","Symbol","RUNTIME","usingFactory","prefixCache","Map","factory","prototype","property","descriptor","baseFunction","value","args","result","call","prefixString","str","prefix","ObjectMap","definition","TypeError","key","Object","hasOwnProperty","set","defineProperty","get","enumerable","keys","instance","v","entries","size","has","getKey","values","fn","forEach","k","obj","fromObject","prefixedInstance"],"mappings":"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","sourcesContent":["import { find } from 'ramda';\n\nconst sDefinition = Symbol('definition');\nconst RUNTIME = {\n  usingFactory: false,\n  prefixCache: new Map(),\n};\n\nfunction factory<T>(\n  prototype: T,\n  property: string,\n  descriptor: PropertyDescriptor,\n) {\n  const baseFunction = descriptor.value;\n  return {\n    ...descriptor,\n    value(this: ThisType<T>, ...args: any) {\n      RUNTIME.usingFactory = true;\n      const result = baseFunction.call(this, ...args);\n      RUNTIME.usingFactory = false;\n      return result;\n    },\n  };\n}\n\nexport type ObjectMapKey<D> = D extends ObjectMap<infer D, infer K, infer V> &\n  infer D\n  ? K\n  : never;\n\nexport type ObjectMapValue<D> = D extends ObjectMap<infer D, infer K, infer V> &\n  infer D\n  ? V\n  : never;\n\nexport function prefixString(str: string, prefix: string = ''): string {\n  return prefix === '' ? str : `${prefix}-${str}`;\n}\n\nexport class ObjectMap<\n  D extends Record<string | number, any>,\n  K extends keyof D,\n  V extends D[K]\n> {\n  private readonly [sDefinition] = new Map();\n\n  constructor(definition: D) {\n    if (!RUNTIME.usingFactory) {\n      throw TypeError(\n        'Instantiating ObjectMap with `new ObjectMap(definition)` is not recommended. ' +\n          'Please use one of the ObjectMap factory functions.',\n      );\n    }\n    if (definition) {\n      for (const key in definition) {\n        if (Object.prototype.hasOwnProperty.call(definition, key)) {\n          this[sDefinition].set(key, definition[key]);\n          Object.defineProperty(this, key, {\n            get() {\n              return this[sDefinition].get(key);\n            },\n            enumerable: true,\n          });\n        }\n      }\n    }\n  }\n\n  @factory\n  static fromObject<\n    D extends Record<string | number, any>,\n    K extends keyof D,\n    V extends D[K]\n  >(definition: D) {\n    return new ObjectMap(definition) as ObjectMap<D, K, V> & D;\n  }\n\n  @factory\n  static fromKeys<K extends string>(keys: K[]) {\n    const definition = {} as Record<K, K>;\n    for (const key of keys) {\n      definition[key] = key;\n    }\n    return new ObjectMap(definition) as ObjectMap<{ [V in K]: V }, K, K> &\n      { [V in K]: V };\n  }\n\n  @factory\n  static prefixKeys<K extends string>(keys: K[], prefix: string = '') {\n    const definition = {} as Record<K, string>;\n    for (const key of keys) {\n      definition[key] = prefixString(key, prefix);\n    }\n    return new ObjectMap(definition) as ObjectMap<\n      { [V in K]: string },\n      K,\n      string\n    > &\n      { [V in K]: string };\n  }\n\n  static getKey<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n    value: V,\n  ): K {\n    const [key = null] =\n      find<[K, V]>(([, v]) => v === value, [...ObjectMap.entries(instance)]) ||\n      [];\n    return key;\n  }\n\n  static entries<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<[K, V]> {\n    return instance[sDefinition].entries();\n  }\n\n  static size<K extends keyof D, V extends D[K], D>(\n    instance: ObjectMap<D, K, V> & D,\n  ): number {\n    return instance[sDefinition].size;\n  }\n\n  static has<K extends keyof D, V extends D[K], D>(\n    instance: ObjectMap<D, K, V> & D,\n    key: K,\n  ): boolean {\n    return instance[sDefinition].has(key);\n  }\n\n  static hasValue<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n    value: V,\n  ): boolean {\n    return !!ObjectMap.getKey(instance, value);\n  }\n\n  static keys<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<K> {\n    return instance[sDefinition].keys();\n  }\n\n  static values<D, K extends keyof D, V extends D[K]>(\n    instance: ObjectMap<D, K, V> & D,\n  ): IterableIterator<V> {\n    return instance[sDefinition].values();\n  }\n\n  static forEach<D, K extends keyof D, V extends D[K]>(\n    fn: (value: V, key: K, map: ObjectMap<D, K, V> & D) => void,\n    instance: ObjectMap<D, K, V> & D,\n  ): void {\n    return instance[sDefinition].forEach((v, k) => fn(v, k, instance));\n  }\n\n  static filter<D extends Record<K, V>, K extends keyof D, V extends D[K]>(\n    fn: (value: V, key: K) => boolean,\n    instance: ObjectMap<D, K, V> & D,\n  ) {\n    const obj = {} as Record<K, V>;\n    ObjectMap.forEach((v, k) => {\n      if (fn(v, k)) {\n        obj[k] = v;\n      }\n    }, instance);\n    return ObjectMap.fromObject(obj);\n  }\n\n  static prefixValues<\n    D extends Record<K, string>,\n    K extends keyof D,\n    V extends D[K]\n  >(instance: ObjectMap<D, K, V> & D, prefix = '') {\n    if (prefix === '') {\n      return instance;\n    }\n    if (!RUNTIME.prefixCache.has(prefix)) {\n      RUNTIME.prefixCache.set(prefix, new Map());\n    }\n    if (!RUNTIME.prefixCache.get(prefix).has(instance)) {\n      const definition = {} as Record<K, string>;\n      ObjectMap.forEach((value, key) => {\n        definition[key] = prefixString(value, prefix);\n      }, instance);\n      const prefixedInstance = ObjectMap.fromObject(definition);\n      RUNTIME.prefixCache.get(prefix).set(instance, prefixedInstance);\n    }\n    return RUNTIME.prefixCache.get(prefix).get(instance) as ObjectMap<\n      { [V in K]: string },\n      K,\n      string\n    > &\n      { [V in K]: string };\n  }\n}\n"],"file":"ObjectMap.js"}