{"version":3,"sources":["lib/ObjectMap/ObjectMap.ts"],"names":["sDefinition","Symbol","RUNTIME","usingFactory","factory","prototype","property","descriptor","baseFunction","value","args","result","call","prefixString","str","prefix","ObjectMap","definition","Map","TypeError","key","Object","hasOwnProperty","set","defineProperty","get","enumerable","keys","instance","v","entries","size","has","getKey","values","fn","forEach","k"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAGC,MAAM,CAAC,YAAD,CAA1B;AACA,IAAMC,OAAO,GAAG;AACdC,EAAAA,YAAY,EAAE;AADA,CAAhB;;AAIA,SAASC,OAAT,CACEC,SADF,EAEEC,QAFF,EAGEC,UAHF,EAIE;AACA,MAAMC,YAAY,GAAGD,UAAU,CAACE,KAAhC;AACA,yCACKF,UADL;AAEEE,IAAAA,KAFF,mBAEoC;AAChCP,MAAAA,OAAO,CAACC,YAAR,GAAuB,IAAvB;;AADgC,wCAANO,IAAM;AAANA,QAAAA,IAAM;AAAA;;AAEhC,UAAMC,MAAM,GAAGH,YAAY,CAACI,IAAb,OAAAJ,YAAY,GAAM,IAAN,SAAeE,IAAf,EAA3B;AACAR,MAAAA,OAAO,CAACC,YAAR,GAAuB,KAAvB;AACA,aAAOQ,MAAP;AACD;AAPH;AASD;;AAYM,SAASE,YAAT,CAAsBC,GAAtB,EAAgE;AAAA,MAA7BC,MAA6B,uEAAZ,EAAY;AACrE,SAAOA,MAAM,KAAK,EAAX,GAAgBD,GAAhB,aAAyBC,MAAzB,cAAmCD,GAAnC,CAAP;AACD;;IAEYE,S;AAOX,qBAAYC,UAAZ,EAA2B;AAAA;;AAAA;;AAAA,SAFTjB,WAES,IAFM,IAAIkB,GAAJ,EAEN;;AACzB,QAAI,CAAChB,OAAO,CAACC,YAAb,EAA2B;AACzB,YAAMgB,SAAS,CACb,kFACE,oDAFW,CAAf;AAID;;AACD,QAAIF,UAAJ,EAAgB;AAAA,iCACHG,KADG;AAEZ,YAAIC,MAAM,CAAChB,SAAP,CAAiBiB,cAAjB,CAAgCV,IAAhC,CAAqCK,UAArC,EAAiDG,KAAjD,CAAJ,EAA2D;AACzD,UAAA,KAAI,CAACpB,WAAD,CAAJ,CAAkBuB,GAAlB,CAAsBH,KAAtB,EAA2BH,UAAU,CAACG,KAAD,CAArC;;AACAC,UAAAA,MAAM,CAACG,cAAP,CAAsB,KAAtB,EAA4BJ,KAA5B,EAAiC;AAC/BK,YAAAA,GAD+B,iBACzB;AACJ,qBAAO,KAAKzB,WAAL,EAAkByB,GAAlB,CAAsBL,KAAtB,CAAP;AACD,aAH8B;AAI/BM,YAAAA,UAAU,EAAE;AAJmB,WAAjC;AAMD;AAVW;;AACd,WAAK,IAAMN,KAAX,IAAkBH,UAAlB,EAA8B;AAAA,cAAnBG,KAAmB;AAU7B;AACF;AACF;;;;+BAOCH,U,EAAe;AACf,aAAO,IAAID,SAAJ,CAAcC,UAAd,CAAP;AACD;;;6BAGiCU,I,EAAW;AAC3C,UAAMV,UAAU,GAAG,EAAnB;;AAD2C,iDAEzBU,IAFyB;AAAA;;AAAA;AAE3C,4DAAwB;AAAA,cAAbP,KAAa;AACtBH,UAAAA,UAAU,CAACG,KAAD,CAAV,GAAkBA,KAAlB;AACD;AAJ0C;AAAA;AAAA;AAAA;AAAA;;AAK3C,aAAO,IAAIJ,SAAJ,CAAcC,UAAd,CAAP;AAED;;;+BAICU,I,EAEA;AAAA,UADAZ,MACA,uEADiB,EACjB;AACA,UAAME,UAAU,GAAG,EAAnB;;AADA,kDAEkBU,IAFlB;AAAA;;AAAA;AAEA,+DAAwB;AAAA,cAAbP,KAAa;AACtBH,UAAAA,UAAU,CAACG,KAAD,CAAV,GAAkBP,YAAY,CAACO,KAAD,EAAML,MAAN,CAA9B;AACD;AAJD;AAAA;AAAA;AAAA;AAAA;;AAKA,aAAO,IAAIC,SAAJ,CAAcC,UAAd,CAAP;AAMD;;;2BAGCW,Q,EACAnB,K,EACG;AAAA,iBAED,iBAAa;AAAA;AAAA,YAAIoB,CAAJ;;AAAA,eAAWA,CAAC,KAAKpB,KAAjB;AAAA,OAAb,qBAAyCO,SAAS,CAACc,OAAV,CAAkBF,QAAlB,CAAzC,MACA,EAHC;AAAA;AAAA;AAAA,UACIR,GADJ,uBACU,IADV;;AAIH,aAAOA,GAAP;AACD;;;4BAGCQ,Q,EAC0B;AAC1B,aAAOA,QAAQ,CAAC5B,WAAD,CAAR,CAAsB8B,OAAtB,EAAP;AACD;;;yBAGCF,Q,EACQ;AACR,aAAOA,QAAQ,CAAC5B,WAAD,CAAR,CAAsB+B,IAA7B;AACD;;;wBAGCH,Q,EACAR,G,EACS;AACT,aAAOQ,QAAQ,CAAC5B,WAAD,CAAR,CAAsBgC,GAAtB,CAA0BZ,GAA1B,CAAP;AACD;;;6BAGCQ,Q,EACAnB,K,EACS;AACT,aAAO,CAAC,CAACO,SAAS,CAACiB,MAAV,CAAiBL,QAAjB,EAA2BnB,KAA3B,CAAT;AACD;;;yBAGCmB,Q,EACqB;AACrB,aAAOA,QAAQ,CAAC5B,WAAD,CAAR,CAAsB2B,IAAtB,EAAP;AACD;;;2BAGCC,Q,EACqB;AACrB,aAAOA,QAAQ,CAAC5B,WAAD,CAAR,CAAsBkC,MAAtB,EAAP;AACD;;;4BAGCC,E,EACAP,Q,EACM;AACN,aAAOA,QAAQ,CAAC5B,WAAD,CAAR,CAAsBoC,OAAtB,CAA8B,UAACP,CAAD,EAAIQ,CAAJ;AAAA,eAAUF,EAAE,CAACN,CAAD,EAAIQ,CAAJ,EAAOT,QAAP,CAAZ;AAAA,OAA9B,CAAP;AACD;;;;+DAzFAxB,O,kHASAA,O,kHAUAA,O","sourcesContent":["import { find } from 'ramda';\n\nconst sDefinition = Symbol('definition');\nconst RUNTIME = {\n  usingFactory: false,\n};\n\nfunction factory<T>(\n  prototype: T,\n  property: string,\n  descriptor: PropertyDescriptor,\n) {\n  const baseFunction = descriptor.value;\n  return {\n    ...descriptor,\n    value(this: ThisType<T>, ...args) {\n      RUNTIME.usingFactory = true;\n      const result = baseFunction.call(this, ...args);\n      RUNTIME.usingFactory = false;\n      return result;\n    },\n  };\n}\n\nexport type ObjectMapKey<D> = D extends ObjectMap<infer K, infer V, infer T> &\n  infer T\n  ? K\n  : never;\n\nexport type ObjectMapValue<D> = D extends ObjectMap<infer K, infer V, infer T> &\n  infer T\n  ? V\n  : never;\n\nexport function prefixString(str: string, prefix: string = ''): string {\n  return prefix === '' ? str : `${prefix}-${str}`;\n}\n\nexport class ObjectMap<\n  K extends keyof T,\n  V extends T[K],\n  T extends Record<string | number, any>\n> {\n  private readonly [sDefinition] = new Map();\n\n  constructor(definition: T) {\n    if (!RUNTIME.usingFactory) {\n      throw TypeError(\n        'Instantiating ObjectMap with `new ObjectMap(definition)` is not recommended. ' +\n          'Please use one of the ObjectMap factory functions.',\n      );\n    }\n    if (definition) {\n      for (const key in definition) {\n        if (Object.prototype.hasOwnProperty.call(definition, key)) {\n          this[sDefinition].set(key, definition[key]);\n          Object.defineProperty(this, key, {\n            get() {\n              return this[sDefinition].get(key);\n            },\n            enumerable: true,\n          });\n        }\n      }\n    }\n  }\n\n  @factory\n  static fromObject<\n    K extends keyof T,\n    V extends T[K],\n    T extends Record<string | number, any>\n  >(definition: T) {\n    return new ObjectMap(definition) as ObjectMap<K, V, T> & T;\n  }\n\n  @factory\n  static fromKeys<T extends string>(keys: T[]) {\n    const definition = {} as Record<T, T>;\n    for (const key of keys) {\n      definition[key] = key;\n    }\n    return new ObjectMap(definition) as ObjectMap<T, T, { [K in T]: K }> &\n      { [K in T]: K };\n  }\n\n  @factory\n  static prefixKeys<T extends string, K extends T>(\n    keys: K[],\n    prefix: string = '',\n  ) {\n    const definition = {} as Record<K, string>;\n    for (const key of keys) {\n      definition[key] = prefixString(key, prefix);\n    }\n    return new ObjectMap(definition) as ObjectMap<\n      K,\n      string,\n      { [V in K]: string }\n    > &\n      { [V in K]: string };\n  }\n\n  static getKey<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n    value: V,\n  ): K {\n    const [key = null] =\n      find<[K, V]>(([, v]) => v === value, [...ObjectMap.entries(instance)]) ||\n      [];\n    return key;\n  }\n\n  static entries<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n  ): IterableIterator<[K, V]> {\n    return instance[sDefinition].entries();\n  }\n\n  static size<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n  ): number {\n    return instance[sDefinition].size;\n  }\n\n  static has<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n    key: K,\n  ): boolean {\n    return instance[sDefinition].has(key);\n  }\n\n  static hasValue<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n    value: V,\n  ): boolean {\n    return !!ObjectMap.getKey(instance, value);\n  }\n\n  static keys<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n  ): IterableIterator<K> {\n    return instance[sDefinition].keys();\n  }\n\n  static values<K extends keyof T, V extends T[K], T>(\n    instance: ObjectMap<K, V, T> & T,\n  ): IterableIterator<V> {\n    return instance[sDefinition].values();\n  }\n\n  static forEach<K extends keyof T, V extends T[K], T>(\n    fn: (value: V, key: K, map: ObjectMap<K, V, T> & T) => void,\n    instance: ObjectMap<K, V, T> & T,\n  ): void {\n    return instance[sDefinition].forEach((v, k) => fn(v, k, instance));\n  }\n}\n"],"file":"ObjectMap.js"}