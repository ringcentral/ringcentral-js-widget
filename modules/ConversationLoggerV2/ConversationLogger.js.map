{"version":3,"sources":["modules/ConversationLoggerV2/ConversationLogger.ts"],"names":["ConversationLogger","name","deps","dep","optional","that","_deps","messageStore","conversationStore","extensionInfo","extensionNumber","conversationMatcher","dataMapping","conversationLogMap","enableCache","storageKey","_logFunction","conversationLoggerOptions","logFunction","_readyCheckFunction","readyCheckFunction","_isLoggedContact","isLoggedContact","_formatDateTime","formatDateTime","dateTimeFormat","_isAutoUpdate","isAutoUpdate","_accordWithLogRequirement","accordWithLogRequirement","_identityFunction","conversationLogIdentityFunction","_autoLogQueue","_autoLogPromise","_lastProcessedConversations","_lastAutoLog","onMessageUpdated","_processConversationLogMap","contactMatcher","addQuerySource","getQueriesFn","uniqueNumbers","readyCheckFn","ready","conversationLogIds","autoLog","ownerId","auth","Promise","all","splice","map","conversation","_processConversationLog","length","_processQueue","push","correspondents","reduce","result","contact","number","phoneNumber","concat","conversationLog","conversationId","lastRecord","Object","keys","date","sort","sortByDate","find","item","conversationLogMatches","conversationLogId","lastActivity","correspondentMatches","_getCorrespondentMatches","match","queries","_autoLogConversation","type","messageTypes","sms","addIfNotExist","numberMap","numbers","self","forEach","selfNumber","selfMatches","selfEntity","correspondentEntity","getLastMatchedCorrespondentEntity","conversationLogItem","triggerMatch","oldMap","tabManager","active","messages","id","accordWithProcessLogRequirement","_queueAutoLogConversation","log","options","redirect","idx","queueIndex","findIndex","_setAutoLog","message","utcTimestamp","creationTime","rolesAndPermissions","serviceFeatures","SMSReceiving","PagerReceiving","enabled","conversationLogMapping","values","allMessages","mapping","slice","logIds","output","LoggerBase","storage","state","action","proxify"],"mappings":"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","sourcesContent":["import {\n  state,\n  storage,\n  action,\n  computed,\n} from '@ringcentral-integration/core';\nimport { Module } from '../../lib/di';\nimport { LoggerBase } from '../../lib/LoggerBaseV2';\nimport { messageTypes } from '../../enums/messageTypes';\nimport {\n  Correspondent,\n  getNumbersFromMessage,\n  sortByDate,\n} from '../../lib/messageHelper';\nimport sleep from '../../lib/sleep';\nimport { proxify } from '../../lib/proxy/proxify';\nimport {\n  getLogId,\n  conversationLogIdentityFunction,\n} from './conversationLoggerHelper';\nimport {\n  ConversationLogItem,\n  ConversationLogMap,\n  Deps,\n} from './ConversationLogger.interface';\nimport { Message } from '../../interfaces/MessageStore.model';\nimport { Entity } from '../../interfaces/Entity.interface';\n\n@Module({\n  name: 'ConversationLogger',\n  deps: [\n    'Auth',\n    'Storage',\n    'ContactMatcher',\n    'ConversationMatcher',\n    'DateTimeFormat',\n    'ExtensionInfo',\n    'MessageStore',\n    'RolesAndPermissions',\n    'ConversationLoggerOptions',\n    { dep: 'TabManager', optional: true },\n  ],\n})\nexport class ConversationLogger<T = any> extends LoggerBase<Deps & T> {\n  _logFunction = this._deps.conversationLoggerOptions.logFunction;\n\n  _readyCheckFunction = this._deps.conversationLoggerOptions.readyCheckFunction;\n\n  protected _isLoggedContact =\n    this._deps.conversationLoggerOptions.isLoggedContact ?? (() => false);\n\n  protected _formatDateTime =\n    this._deps.conversationLoggerOptions.formatDateTime ??\n    ((...args) => this._deps.dateTimeFormat.formatDateTime(...args));\n\n  protected _isAutoUpdate =\n    this._deps.conversationLoggerOptions.isAutoUpdate ?? true;\n\n  protected _accordWithLogRequirement = this._deps.conversationLoggerOptions\n    .accordWithLogRequirement;\n\n  protected _identityFunction = conversationLogIdentityFunction;\n\n  protected _autoLogQueue: ConversationLogItem[] = [];\n\n  protected _autoLogPromise: Promise<void> = null;\n\n  protected _lastProcessedConversations: ConversationLogMap = null;\n\n  protected _lastAutoLog: boolean = null;\n\n  constructor(deps: Deps) {\n    super(deps, {\n      enableCache: true,\n      storageKey: 'ConversationLogger',\n    });\n    this._deps.messageStore.onMessageUpdated(() => {\n      this._processConversationLogMap();\n    });\n    this._deps.contactMatcher.addQuerySource({\n      getQueriesFn: () => this.uniqueNumbers,\n      readyCheckFn: () =>\n        this._deps.messageStore.ready && this._deps.extensionInfo.ready,\n    });\n    this._deps.conversationMatcher.addQuerySource({\n      getQueriesFn: () => this.conversationLogIds,\n      readyCheckFn: () =>\n        this._deps.messageStore.ready && this._deps.extensionInfo.ready,\n    });\n  }\n\n  _shouldInit() {\n    return !!(super._shouldInit() && this._readyCheckFunction());\n  }\n\n  _shouldReset() {\n    return !!(\n      super._shouldReset() ||\n      (this.ready && !this._readyCheckFunction())\n    );\n  }\n\n  @storage\n  @state\n  autoLog = false;\n\n  @action\n  _setAutoLog(autoLog: boolean) {\n    this.autoLog = autoLog;\n  }\n\n  _onReset() {\n    this._lastProcessedConversations = null;\n    this._lastAutoLog = null;\n    this._autoLogPromise = null;\n    this._autoLogQueue = [];\n  }\n\n  async _processQueue() {\n    const { ownerId } = this._deps.auth;\n    await sleep(300);\n    if (ownerId !== this._deps.auth.ownerId) return;\n    await Promise.all(\n      this._autoLogQueue\n        .splice(0, 10)\n        .map((conversation) => this._processConversationLog({ conversation })),\n    );\n    if (ownerId === this._deps.auth.ownerId && this._autoLogQueue.length > 0) {\n      this._autoLogPromise = this._processQueue();\n    } else {\n      this._autoLogPromise = null;\n    }\n  }\n\n  _queueAutoLogConversation({\n    conversation,\n  }: {\n    conversation: ConversationLogItem;\n  }) {\n    this._autoLogQueue.push(conversation);\n    if (!this._autoLogPromise) {\n      this._autoLogPromise = this._processQueue();\n    }\n  }\n\n  _getCorrespondentMatches(conversation: ConversationLogItem) {\n    return (\n      (conversation.correspondents &&\n        conversation.correspondents.reduce((result, contact) => {\n          const number = contact.phoneNumber || contact.extensionNumber;\n          return number && this._deps.contactMatcher.dataMapping[number]\n            ? result.concat(this._deps.contactMatcher.dataMapping[number])\n            : result;\n        }, [] as Entity[])) ||\n      []\n    );\n  }\n\n  getLastMatchedCorrespondentEntity(conversation: ConversationLogItem) {\n    const conversationLog = this.conversationLogMap[\n      conversation.conversationId\n    ];\n    if (!conversationLog) {\n      return null;\n    }\n    const lastRecord = Object.keys(conversationLog)\n      .map((date) => this.conversationLogMap[conversation.conversationId][date])\n      .sort(sortByDate)\n      .find((item) => item.conversationLogMatches.length > 0);\n    if (\n      lastRecord &&\n      this._deps.conversationMatcher.dataMapping[\n        lastRecord.conversationLogId\n      ] &&\n      this._deps.conversationMatcher.dataMapping[lastRecord.conversationLogId]\n        .length\n    ) {\n      const lastActivity = this._deps.conversationMatcher.dataMapping[\n        lastRecord.conversationLogId\n      ][0];\n      const correspondentMatches = this._getCorrespondentMatches(lastRecord);\n      return correspondentMatches.find((item) =>\n        this._isLoggedContact(conversation, lastActivity, item),\n      );\n    }\n    return null;\n  }\n\n  async _processConversationLog({\n    conversation,\n  }: {\n    conversation: ConversationLogItem;\n  }) {\n    // await this._deps.conversationMatcher.triggerMatch();\n    await this._deps.conversationMatcher.match({\n      queries: [conversation.conversationLogId],\n    });\n    if (\n      this._isAutoUpdate &&\n      this._deps.conversationMatcher.dataMapping[\n        conversation.conversationLogId\n      ] &&\n      this._deps.conversationMatcher.dataMapping[conversation.conversationLogId]\n        .length\n    ) {\n      // update conversation\n      await this._autoLogConversation({\n        conversation,\n      });\n    } else if (this.autoLog && conversation.type === messageTypes.sms) {\n      // new entry\n      const numbers: string[] = [];\n      const numberMap: Record<string, boolean> = {};\n      /* eslint { \"no-inner-declarations\": 0 } */\n      function addIfNotExist(contact: Correspondent) {\n        const number = contact.phoneNumber || contact.extensionNumber;\n        if (number && !numberMap[number]) {\n          numbers.push(number);\n          numberMap[number] = true;\n        }\n      }\n      addIfNotExist(conversation.self);\n      conversation.correspondents.forEach(addIfNotExist);\n      await this._deps.contactMatcher.match({ queries: numbers });\n      const selfNumber =\n        conversation.self &&\n        (conversation.self.phoneNumber || conversation.self.extensionNumber);\n      const selfMatches =\n        (selfNumber && this._deps.contactMatcher.dataMapping[selfNumber]) || [];\n      const correspondentMatches = this._getCorrespondentMatches(conversation);\n\n      const selfEntity =\n        (selfMatches && selfMatches.length === 1 && selfMatches[0]) || null;\n\n      let correspondentEntity = this.getLastMatchedCorrespondentEntity(\n        conversation,\n      );\n\n      correspondentEntity =\n        correspondentEntity ||\n        (correspondentMatches &&\n          correspondentMatches.length === 1 &&\n          correspondentMatches[0]) ||\n        null;\n      await this._autoLogConversation({\n        conversation,\n        selfEntity,\n        correspondentEntity,\n      });\n    }\n  }\n\n  accordWithProcessLogRequirement(conversationLogItem: ConversationLogItem) {\n    return !!this._accordWithLogRequirement?.(conversationLogItem);\n  }\n\n  _processConversationLogMap() {\n    if (this.ready && this._lastAutoLog !== this.autoLog) {\n      this._lastAutoLog = this.autoLog;\n      if (this.autoLog) {\n        // force conversation log checking when switch auto log to on\n        this._lastProcessedConversations = null;\n      }\n    }\n    if (\n      this.ready &&\n      this._lastProcessedConversations !== this.conversationLogMap\n    ) {\n      this._deps.conversationMatcher.triggerMatch();\n      this._deps.contactMatcher.triggerMatch();\n      const oldMap = this._lastProcessedConversations || {};\n      this._lastProcessedConversations = this.conversationLogMap;\n      if (!this._deps.tabManager || this._deps.tabManager.active) {\n        Object.keys(this._lastProcessedConversations).forEach(\n          (conversationId) => {\n            Object.keys(\n              this._lastProcessedConversations[conversationId],\n            ).forEach((date) => {\n              const conversation = this._lastProcessedConversations[\n                conversationId\n              ][date];\n              if (\n                !oldMap[conversationId] ||\n                !oldMap[conversationId][date] ||\n                conversation.messages[0].id !==\n                  oldMap[conversationId][date].messages[0].id\n              ) {\n                if (this.accordWithProcessLogRequirement(conversation)) {\n                  this._queueAutoLogConversation({\n                    conversation,\n                  });\n                }\n              }\n            });\n          },\n        );\n      }\n    }\n  }\n\n  async _autoLogConversation({\n    conversation,\n    selfEntity,\n    correspondentEntity,\n  }: {\n    conversation: ConversationLogItem;\n    selfEntity?: Entity;\n    correspondentEntity?: Entity;\n  }) {\n    await this.log({\n      conversation,\n      selfEntity,\n      correspondentEntity,\n    });\n  }\n\n  @proxify\n  async log<T>({\n    conversation,\n    ...options\n  }: {\n    conversation: ConversationLogItem;\n  } & T) {\n    super.log({ item: conversation, ...options });\n  }\n\n  @proxify\n  async logConversation<T>({\n    conversationId,\n    correspondentEntity,\n    redirect,\n    ...options\n  }: {\n    conversationId: string;\n    correspondentEntity: Entity;\n    redirect: boolean;\n  } & T) {\n    if (this.conversationLogMap[conversationId]) {\n      await Promise.all(\n        Object.keys(this.conversationLogMap[conversationId])\n          .map((date) => this.conversationLogMap[conversationId][date])\n          .sort(sortByDate)\n          .map((conversation, idx) => {\n            const queueIndex = this._autoLogQueue.findIndex(\n              (item) =>\n                item.conversationLogId === conversation.conversationLogId,\n            );\n            if (queueIndex > -1) {\n              this._autoLogQueue.splice(queueIndex, 1);\n            }\n            return this.log({\n              ...options,\n              conversation,\n              correspondentEntity,\n              redirect: redirect && idx === 0, // only direct on the first item\n            });\n          }),\n      );\n    }\n  }\n\n  get available() {\n    const {\n      SMSReceiving,\n      PagerReceiving,\n    } = this._deps.rolesAndPermissions.serviceFeatures;\n    return !!(\n      (SMSReceiving && SMSReceiving.enabled) ||\n      (PagerReceiving && PagerReceiving.enabled)\n    );\n  }\n\n  @proxify\n  async setAutoLog(autoLog: boolean) {\n    if (this.ready && autoLog !== this.autoLog) {\n      this._setAutoLog(autoLog);\n    }\n  }\n\n  @computed<ConversationLogger>((that) => [\n    that._deps.messageStore.conversationStore,\n    that._deps.extensionInfo.extensionNumber,\n    that._deps.conversationMatcher.dataMapping,\n  ])\n  get conversationLogMap() {\n    const { conversationStore } = this._deps.messageStore;\n    const { extensionNumber } = this._deps.extensionInfo;\n    const conversationLogMapping =\n      this._deps.conversationMatcher.dataMapping ?? {};\n    const messages = Object.values(conversationStore).reduce(\n      (allMessages, messages) => [...allMessages, ...messages],\n      [],\n    );\n    const mapping: ConversationLogMap = {};\n    messages\n      .slice()\n      .sort(sortByDate)\n      .forEach((message) => {\n        const { conversationId } = message;\n        const date = this._formatDateTime({\n          type: 'date',\n          utcTimestamp: message.creationTime,\n        });\n        if (!mapping[conversationId]) {\n          mapping[conversationId] = {};\n        }\n        if (!mapping[conversationId][date]) {\n          const conversationLogId = getLogId({ conversationId, date });\n          mapping[conversationId][date] = {\n            conversationLogId,\n            conversationId,\n            creationTime: message.creationTime, // for sorting\n            date,\n            type: message.type,\n            messages: [],\n            conversationLogMatches:\n              conversationLogMapping[conversationLogId] || [],\n            // The reason for passing extensionNumber here is to filter the correspondence in the group conversation(type paper, and Only it has extensionNumber) that contains its own information.\n            ...getNumbersFromMessage({ extensionNumber, message }),\n          };\n        }\n        mapping[conversationId][date].messages.push(message);\n      });\n    return mapping;\n  }\n\n  @computed<ConversationLogger>((that) => [that.conversationLogMap])\n  get conversationLogIds() {\n    const logIds: string[] = [];\n    Object.keys(this.conversationLogMap).forEach((conversationId) => {\n      Object.keys(this.conversationLogMap[conversationId]).forEach((date) => {\n        logIds.push(\n          this.conversationLogMap[conversationId][date].conversationLogId,\n        );\n      });\n    });\n    return logIds;\n  }\n\n  @computed<ConversationLogger>((that) => [that.conversationLogMap])\n  get uniqueNumbers() {\n    const output: string[] = [];\n    const numberMap: Record<string, boolean> = {};\n    function addIfNotExist(contact: Correspondent = {}) {\n      const number = contact.phoneNumber || contact.extensionNumber;\n      if (number && !numberMap[number]) {\n        output.push(number);\n        numberMap[number] = true;\n      }\n    }\n    Object.keys(this.conversationLogMap).forEach((conversationId) => {\n      Object.keys(this.conversationLogMap[conversationId]).forEach((date) => {\n        const conversation = this.conversationLogMap[conversationId][date];\n        addIfNotExist(conversation.self);\n        conversation.correspondents.forEach(addIfNotExist);\n      });\n    });\n    return output;\n  }\n\n  getConversationLogId(message: Message) {\n    if (!message) {\n      return;\n    }\n    const { conversationId } = message;\n    const date = this._formatDateTime({\n      type: 'date',\n      utcTimestamp: message.creationTime,\n    });\n    return getLogId({\n      conversationId,\n      date,\n    });\n  }\n\n  get dataMapping() {\n    return this._deps.conversationMatcher.dataMapping;\n  }\n}\n"],"file":"ConversationLogger.js"}